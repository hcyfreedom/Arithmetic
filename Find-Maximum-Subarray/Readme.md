# 寻找最大子数组，得出下标及最大子数组的和。
【子数组肯定是连续的】
## 基本思路
假定所要处理的数组是A[low..high],并且采用**分治法**：分解-解决-合并；
<br>按照分治法的思想，将数组划分为两个规模尽量相同的子数组，也就是说，找到数组的中央位置，比如mid，然后考虑求解两个子数组A[low..mid]，A[mid+1..high]。
<br>A[low..hight]的任何连续子数组A[i..j]所处的位置必然是以下三种情况之一：<br>
1. 完全处于子数组A[low..mid]中
2. 完全处于子数组A[mid+1..high]中
3. 跨越了中点。
    
实际上，我们所要求解的一个最大子数组必然是  完全位于A[low..mid]中、完全位于A[mid+1..high]中、跨越中点的
所有子数组中和最大者。
<br>可以递归求A[low..mid]和A[mid+1..high]，因为这两个问题
仍然是最大子数组问题，只是规模更小。
<br>所以，先看寻找跨越中点的最大子数组，然后在三种情况中选取和最大者。
    
## 寻找跨越中点的最大子数组
我们可以从中点mid为分界，分别向两边寻找。即找出两个子数组A[i..mid]和
A[mid+1..j]的最大子数组，然后将其合并就行。
### findMaxCrossingSubArray()
需要数组A、下标low、high、mid，返回一个下标元组，划定跨越中点的最大子数组的边界，
并返回最大数组中值得和。

